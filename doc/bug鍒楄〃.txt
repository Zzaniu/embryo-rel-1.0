
Copyright(c) 2015-6-5 Shangwen Wu	

1、embryo-dbg1.2: 

	（1）I2C控制器，在发送起始字节并且得到相应的ACK之后，再发送第二个数据字节的时候，收不到设备的ACK
	解决：该问题出现在特定目标板上，目标板采用了一个I2C接口的GPIO扩展芯片，该芯片仅对特定的数据产生响应

	（2）程序在未初始化cache的情况下，也可使用kseg0空间
	解决：未使能CONFIG寄存器的KSEG0区域的缓存功能，使能该功能后，必须等待cache初始化完毕后，才能使用该空间

2、embryo-dbg1.3: 

	（1）使用缓存后，字符串出现不停打印某一个字符的现象（一般是字符串的第二、三个字符）
	解决：在字符打印函数serial_putc中的跳转指令后出现了一条写内存命令sb，需要在跳转指令之后多加一个NOP指令
			
	（2）使用缓存后，出现短时间程序阻塞
	解决：设置PLL时，进行判断函数is_set_cpu_pll_hard后，添加一个NOP，现象消失。（在添加了异常向量后该BUG消失）

2、embryo-dbg1.4: 

	（1）添加异常向量时，如果异常处理程序添加一定数量的打印函数后，程序将出现cache error异常
	解决：原因由cache初始化错误引起，在初始化I-cache过程中，ECC寄存器没有初始化为0，并且初始化cache行时，内存地址没有严格按照0x80000000~0x800004000的地址进行

3、embryo-dbg1.5:

	（1）内存参数配置寄存器空间在没有使能的情况下仍然能够访问

	（2）DDR3的写校准过程相比PMON要长1秒钟左右时间
	
	（3）部分只读MC寄存器与PMON不一致

	（4）DD3读校准过程要长于PMON

4、embryo-all：
	
	（1）在某些DEMO板上进行测试时，出现embryo起不来的情况，初步怀疑与PCIE有关

5、embryo-2.1:
	
	（1）行编辑器进行字符串的插入字符串和删除字符串时，出现因为\b而引起的光标重影

	（2）未处理串口输出超过上位机串口终端边界的字符显示异常的情况

	（3）未启用行编辑器的ctrl+" "字符串标记功能

	（4）未处理lib/queue.c中put/get函数操作失败的情况（比如队列满或者空）

6、embryo-2.3

	（1）embryo的printf函数在使用%x打印longlong型数据时，出现要打印的变量比实际打印的数据地址往后偏移了4字节长度的bug，理论上来说%x应该打印longlong变量的低4字节，然而实际打印出来的值却是longlong低4字节还要往前的4字节位置的无效数据。pmon下也有此种问题，初步怀疑可能是mips的8字节地址对齐要求，也可能与stdarg.h中的实现相关。

	（2）在vsprintf函数中使用64位%和/运算时报以下错误:
	/root/Desktop/work/embryo/embryo/lib/liblib.o: In function `llbtoa':
	(.text+0x1554): undefined reference to `__umoddi3'
	/root/Desktop/work/embryo/embryo/lib/liblib.o: In function `llbtoa':
	(.text+0x1554): relocation truncated to fit: R_MIPS_26 against `__umoddi3'
	/root/Desktop/work/embryo/embryo/lib/liblib.o: In function `llbtoa':
	(.text+0x160c): undefined reference to `__udivdi3'
	/root/Desktop/work/embryo/embryo/lib/liblib.o: In function `llbtoa':
	(.text+0x160c): relocation truncated to fit: R_MIPS_26 against `__udivdi3'
	以上错误仅在embryo中存在，而pmon没有；尝试过pmon的编译和链接选项均无效果，出错原因在于embryo环境下不支持64位的除法和求模运算，因此编译器自动检测该问题并对"/"和"%"运算符进行重载，转而调用libc的__udivdi3和__moddi3函数，而该函数并未在embryo中实现，因此编译过程报出以上错误，在这里通过采用Linux下的__div64_u32函数取代__divdi3函数进而回避了这一问题，但是为何pmon可以直接使用64位除法运算而embryo却不能进行这一个操作却并没有找到原因。
	
6、embryo-2.4

	（1）VGA显示发现有尾纹，PMON下有同样的现象

	（2）VGA实现方式效率很低，当提高色深和显示分辨率时，显示延迟相当严重
	解决：建立一个冗余的矩阵位图，来映射当前控制台显示界面的显存，每次操作显存时不直接调用效率低下的fb_move进行显存数据搬移，而是通过这个位图来判断是否真正操作显存，从而减少调用fb_move次数，提高效率。位图和实际显示的画面应该是同步的，每次显示界面发生变化时，同时还要将这个变化更新到位图。但是这不能根本性解决问题，当使用更高的分辨率并且更高的色深时，如果需要进行修改的像素点过多，界面显示仍然会变得很卡顿。

	（3）通过增加一个位图提高显示控制台滚动性能的时候，为这个位图分配内存空间而调用malloc或者全局的一个大数组会引起程序不明原因的卡死，或者程序执行异常
	解决：低级错误。malloc分配函大小出错

	（4）malloc函数使用的还是以前zloader遗留代码使用的版本，最大仅有4MB空间可分配，以后使用可能会引起问题
	解决：修改malloc库函数使用某个固定的堆空间
	
	（5）使用“；”分割多个命令时，若“；”分割的命令过多时出现地址越界
	解决：在command.c的命令解析函数do_cmd中添加对一行命令数的限制，防止cmdlist数组越界

	（6）光标颜色不对，前景色是黄色，背景色是黑色
	解决：通过修改显示像素点的位操作修复了该问题

	（7）光标回退不能跨越到上一行
	
6、embryo-2.5

	（1）读写内存命令"d"和"m"这两个命令目前仅支持32位地址，高32位将自动被忽略（不被符号扩展）

	（2）写内存命令，使用volatile直接进行内存写操作，而不是flush cache，这可能会带来数据一致性问题

	（3）PMON的系统内存分配函数kern_malloc存在BUG，当需要分配一个大小大于MAXALLOCSAVE字节的空间时，如果对应于bucket数组位置的next指针不为空，将会出现地址越界。原因在于大于MAXALLOCSAVE的空间与16K*MINALLOCSIZE～MAXALLOCSAVE大小的空间在bucket数组中保存的索引是一样的，倘若某个程序在调用了kern_malloc分配了一个MAXALLOCSAVE大小的空间，随后又调用kern_free将该空间释放，这样一来此时bucket中的next不为空，并指向这个大小为MAXALLOCSAVE的空间，而此时如果另一个程序需要调用kern_malloc分配一个大于MAXALLOCSAVE大小的空间，程序会将之前释放的MAXALLOCSAVE大小的空间基地址返回，而调用者并不知道其分配的实际空间大小其实只有MAXALLOCSAVE字节，因而会导致访问地址越界。embryo在者方面做了调整，对于大于MAXALLOCSAVE字节的空间将不用于buckets链表管理，而直接通过__kmem_alloc/__kmem_free进行空间的分配和释放，另外通过kmemusage记录该空间的大小信息

6、embryo-2.6

	（1）在PMON的系统调用函数sys_socket函数中，通过falloc函数分配了file结构后，如果socreate执行失败，对于falloc函数的释放操作存在BUG。在falloc会调用lib/open.c下的open函数，而在释放操作的fdremove以及ffree函数却没有执行对应的close操作，使得释放操作后_file[fd].valid并没有释放，导致该资源泄漏。在embryo-2.6版本中修正了这个问题

	（2）相同的embryo分别在J1051和J1151下显示效果不一致，在J1051高分辨率显示下字符界面更为流畅，而J1151则显得卡顿，目前不排除显示器的原因

	（3）PMON的getsock函数，使用fd_nfile与fdes进行比较不太合理，fdes应当与fdesec中最大的fd进行比较而非与当前文件打个数进行表较

	（4）在编写rip_output函数时，对IP协议中的某些字段进行赋值时，程序执行发生异常，发现embryo打印一段莫名其妙的数字，然后卡死，像是程序跑飞，后通过ejtag跟踪当前PC指针，发现程序执行到了start.S中的异常处理程序，然后提示引起异常的地址刚好时进行某个IP字段进行赋值的地方，该地址为一个奇数地址，故猜测，导致异常的原因很可能是程序对一个非四字节对齐的地址进行了写四字节访问，后将该字段地址强行改为4字节对齐后程序正常，因此更加确定了我的推测。跟踪程序，因为通过mbuf分出来的首地址肯定是4字节对齐，而结构体又有编译器自动对其成员变量进行4字节对齐的功能，因此推断计算m_date的地方可能算错，最终定位到了MH_ALIGN这个定义有问题，修改后问题解决。通过以上的调试过程，发现如果结构体定义不当，比如取消了编译器自动对齐的功能的情况下，再对其非4边界对齐的成员变量进行4字节访问（或2字节），将会导致程序触发MIPS指令异常。因为MIPS指令不支持非对齐访问

	（5）PMON的ip_output函数中，在处理转发数据报文以及RAW的IP头时，存在设计问题。当用于传入一个非空的ipoptions选项时，会将该选项插入到IP头中，并更新IP报文长度以及IP帧头长度，而如果该报文为RAW帧或者转发帧，则在实际插入选项后，并不会更新IP头的长度，也就是说IP头还是插入选项之前的长度，而新插入的选项信息则被当成了数据部分，从而造成传输异常
	解决：PMON在针对RAW的IP头插入IP选项时有要求，1）in_pcb中的选项和RAW头中的选项数据不能被同时指定，只能有其中一个，这一点在rip_output中会进行预判；2）由RAW中指定选项数据时，其选项长度必须在调用rip_output函数之前被正确设置到IP帧头中。但是以上两点在RAW帧并且inp_pcb中的选项数据存在的情况下仍然会出问题

	（6）在PMON的sosend函数实现中，对于传入的top参数处理很奇怪，当传入的uio与top同时不为空时，根据代码设计将分配一个标准格式的mbuf,而后用于传入的top中的信息被直接丢弃，而将uio中的数据拷贝到新创建的mbuf中，并且将数据总长度更新到mbuf中，而此时的mbuf为标准格式，不会保存总长度信息，而只有pkt格式的mbuf才会保存整个数据长度。这将对以后的使用存在隐患

	（7）在PMON的ip_insertoptions函数中，对选项长度的限制不正确，代码中要求option长度加上ip_len不小于IP最大长度65535，实际上IP选项长度因为受到IP头长度字段的限制而不能超过40个字节，而如果传入的opt参数长度产过40个字节，其超过40个字节的部分将被当成IP数据部分而引起错误
	解决：在调用ip_insertoptions函数之前，对option长度进行判断

	（8）PMON的ip_insertoptions函数中，对于mbuf大小不足以插入选项数据而需要新创建一个pkt格式的mbuf的情况，代码中没有将原来的pkt中包含的标志信息以及pkt头拷贝到新创建的mbuf中，从而会导致PKT头信息丢失

	（9）PMON的回环接口lo0默认没有设置127.0.0.1的回环地址，只有在通过ifaddr命令（ifconfg命令不会有此效果）为任一个接口设置IP地址时，才会自动为回环接口添加地址127.0.0.1

	（10）PMON的ifconf函数实现中，对space的处理不太合理，在对sockaddr的实际长度大于通用sockaddr结构本身长度的处理时，space在完成拷贝数据前，便对space减去了sa_len - sizeof(sockaddr)，而如果空间不够或者拷贝过程中出错，则这段多减去的空间也会被认为是有效数据，从而导致返回的长度信息与实际的有效数据空间不匹配
	解决：embryo在每次确保了可用空间足够并且操作成功之后才对space进行修改

	（11）在添加一个radix节点的rn_addroute函数中，在确定重复链表的插入位置以及掩码链表的插入位置处理过程中，缺少对掩码相同的情况的处理（当然一般不可能发生，因为rn_addmask将会返回失败），从而导致对于掩码相同的节点将会重复添加到这些链表的结尾。
	解决：embryo新增对这样情况的处理，一旦出现掩码相同的（非相同的地址引用）情况，则不做任何链表节点插入的操作，而是直接报错，并返回。

	（12）当前版本embryo对设置一个接口地址时，不会检查地址是否重复，仍然会将该重复地址添加到ifnet的地址链表中，只是其ifaddr接口的IFA_ROUTE不会被置位

	（13）PMON的sblock宏定义返回值存在问题，该宏（在socketvar.h）返回值始终为0，与实际逻辑不符。
	解决：embryo取消了该宏定义，而在uipc_socket使用函数实现了该部分逻辑，并在函数中添加了关闭中断的操作。

	（14）PMON的串口控制台下，如果通过调试助手一次性输入较长（超过了VGA显示控制台一行的长度）命令，并且同时打开了VGA显示，且光标在显示器最下面一行，那么PMON会丢失超过VGA行长的部分字符数据
	解决：初步判定为因软件设计导致的性能问题。初步分析，当输入的数据超过了VGA显示控制台的最后一行，那么此时多出行长部分的那个字符将引起整个屏幕显示向上翻滚一行，而这需要软件花费相当大的时间进行写显存操作，而这段时间内，scandevs函数忙于显存刷新，没有时间处理串口终端输入，从而导致部分字符数据丢失。通过启用设备中断和修改软件设计可解决该BUG，但目前版本中embryo仍旧采用类似PMON的处理方式。

	（15）PMON的recvit函数中对control信息的处理不太合理，soreceive中对control信息从socket接收buffer拷贝到传入的上层control指针时，其信息可能组织成一条链表，而在recvit函数将control指针的数据拷贝到应用层的时候却采用单个mbuf进行数据拷贝，这样将导致除表头节点外其他的数据全部丢失
	解决：embryo对recvit函数进行修改，使之支持基于mbuf链表的control信息拷贝

	（16）soreceive函数实现中，当用户函数设置了MSG_WAITALL选项并且当前接收缓冲区为空时，PMON对缓冲区阻塞存的处理在疑问，PMON在没有调用sbunlock解释放sb访问锁的情况下又调用sbwait函数等待定时接收任务往sb中填写数据。问题在于没有获得sb访问锁的情况下，定时接收任务会将数据填写到sb中吗？？？

	（17）icmp_error函数存在bug，该函数对ip_len、ip_off、ip_id几个字段的网络字节序与主机字节序处理相当混乱，其中通过ip_dooptions函数调用icmp_error进行错误处理时，调用者将以上字段统统转换为网络字节序，而icmp_errpr函数在未进行主机字节序转换的情况下直接使用了ip_len作为字段值，导致在获取ip长度时出错；并且在传入后续的icmp_reflect以及ip_output函数时，icmp_error将其传入ip报文的上述字段处理为网络字节序，而icmp_reflect和ip_output这两个函数均要求传入参数的ip报文中的上述三个字段为主机字节序
	解决：bios强制要求上层调用者保证在传入icmp_error函数的ip报文中，ip_off、ip_len、ip_id三个字段的字节序均为主机字节序

7、embryo-2.7

	（1）gmac网口驱动模块的synopGMAC_init_network_interface函数中ifnet->ifaddr的初始化函数if_attach对链路层的sockaddr_dl空间分配出错，if_attach需要根据ifnet的if_addrlen字段来为保存MAC地址预留额外的长度，但是该字段在后面的ether_ifattach函数中才被初始化为6（以太网地址长度），此时该字段为0，而ether_ifattach访问该空间时将导致越界
	解决：bios将if_addrlen字段的初始化放在if_attach函数之前进行

	（2）通过SIOCSIFFLAGS设置ifnet标识时，会引起ifioctl函数重复调用的问题，比如多次up一个网口，将引起调用多次网口驱动的open函数，可能导致内存泄漏或者其他问题
	解决：PMOM的ifioctl函数设计不合理，在现有设计方式上，embryo将在上层调用方进行这种累赘般的重复性检查

	（3）cache.S文件的CPU_FlushDCache函数中对于单路cache处理的跳转语句（第854行）出现低级错误
	解决：根据cache处理操作，处理跳转位置应当为下下个3标号处（第929行）

	（4）PMON的cache初始化函数scache_init以及godson2_cache_init中对缓存初始化大小的设置存在疑问
	待定解决：从cache.S文件的flush操作了解到每次刷新操作的大小为整个cache大小，而上述初始化函数中使用的大小仅仅是一个cache set（1路cache）大小，而非整个cache大小，这可能导致其他几路cache没有初始化（根据索引型操作，地址高位表示cache路数，而此处，这些高位bit全为0），然而实际使用过程中，并未出现因为这些原因导致的莫名其妙的程序问题

	（6）start.S的scache_init函数中，2级缓存大小设置错误
	解决：目前2H CPU的二级cache大小为512K/4Way，而非1M/4Way

7、embryo-2.8

	（1）PMON的synopGMAC_setup_tx_desc_queue函数为对链式描述符进行处理，没有对将下一个描述符指针复制到上一个描述符的buffer2字段，而在这种情况下调用后续的初始化函数synopGMAC_set_rx_qptr函数将引起空指针异常。
	解决：embryo下将修复该问题

	（2）PMON下对描述符的定义依赖于ENH_DESC和ENH_DESC_8W宏定义，而目前PMON仅使用了16位的描述符结构，并且在分配空间时，多分配了16个字节的冗余数据，DMA不使用该数据。但是在DMA的设置中，没有将描述符的间隔正确定义为16个字节，而是设置为了8个字节，这点让人疑惑

	（3）mii_ethtool_gset函数中当自适应打开，但是协商失败时，mii_nway_result函数返回的duplex信息是不确定的（返回值没有被初始化）
	解决：在新BIOS中将修正该问题

	（4）网口宏定义DmaRxFlowCtrlAct4K宏定义错误，根据手册中的描述，该宏定义值应当为0x00000600
	解决：在新BIOS中将修正该问题
	
	（5）arpresolve函数，当ifnet->if_flags的IFF_NOARP置位时，没有对传入参数m占用的内存区域进行释放，而直接返回失败并退出该函数
	解决：在新BIOS中将修正该问题
	
	（6）PMON中arp_ifinit函数将传入的ifaddr设置成RTF_CLONING类型，从而导致凡是为以太网接口配置地址新增的路由均为CLONING类型，而在arp_request(RTM_ADD)函数中将根据是否为非点对点接口而重复设置CLONING标识位，由于前面的设置将导致此处对非点对点接口的判断失去意义
	解决：在新BIOS中将修正该问题

	（7）对ifa_rtreqest的最后一个参数存在疑问，当通过rrtrequest函数进行ADD或者RESOLVE操作时，此处传入rtentry指针，而该参数默认是ifaddr类型，不知是否会引起问题
	解决：未对该问题进行修正

	（8）ether_input函数对于接收到非本机的单播地址，对是否在混杂模式下接收该报文的判断存在问题
	解决：新bios修正为在混杂模式下，接收非本机的单播地址，非混杂模式下，丢弃该类型报文

	（9）PMON的synopGMAC_set_tx_ptr函数存在多个无效参数，调用者未初始化该参数，而实际上被调函数体中也没有操作这些参数
	解决：新BIOS中将修正该问题

	（10）PMON的synopGMAC_open函数需要调用两次synopGMAC_mac_init才能网络通信
	解决：通过跟踪发现，基本原因可能与问题（3）有关，并且当使用强制设置时，mac的链路与MII端口设置需要在时能mac收发功能之前进行

	（11）PMON与BIOS下对88E1111下的延时操作与内核的marvel PHY驱动不一致，代码中先对PHY进行RGMII延时配置，然后进行复位操作，并能正常使用，而内核实现则是先进行复位，在进行延时设置
	解决：问题不明

	（12）PMON的arplookup函数对目的地址进行路由匹配时，传入的参数sin多余字段没有被清零，这样在某些情况下（栈中该位置不为0）将匹配不到radix树中的专属路由，因为专属路由必定为host路由，其mask值为0，匹配长度为整个sockaddr域，而如果多余字段未清零将会导致整个长度的匹配失败，导致专属路由匹配失败，这样一来，如果rtalloc1函数的report参数为1，那么将创建多于的专属路由，进而发生未知问题
	解决：新BIOS中将修正该问题，在arplookup调用__rt_alloc函数前将参数sin清零

	（13）PMON与我们的BIOS必须关闭GMAC的接收帧MAC地址过滤器，否则收不到对方发给我们的单播报文，而内核下无需关闭

8、embryo-3.0

	（1）PMON的strpat通配符比较函数对于处理"123123123"和"*123"之类的字符串比较时出现匹配失败的情况
	解决：新BIOS采用了自己的实现算法，解决了该问题

	（2）PMON的netio_close函数没有对netio_open函数中分配的内存进行释放，造成内存泄漏
	解决：新BIOS将修复这一问题

	（3）PMON的in_pcbconnect函数对于本地和远端地址重用的问题存在漏洞，in_pcbconnect函数对与本地与远端会进行一次绝对匹配，也就是说哪怕设置本地地址和端口重用，只要对端地址一样，那么connect函数或者udp的发送函数还是会出现地址重用错误。但是在进行绝对匹配时，参与匹配的参数之一——本地端口有可能时未决的（当没有调用bind函数绑定本地端口和地址，导致端口为0），如果事先调用bind函数将端口事先确定，那么不会存在问题。但是一旦发生以下这种情况，将会导致本地-远端地址完全一样但是程序又检查不出来的情况：当事先未bind端口，并且socket设置了地址或者端口重用选项。此时，由于本地端口为0，可能导致in_pcbconnect错过与某个远端地址和端口、本地地址和当前设置一样，而本地端口不为0的匹配项，而随后调用in_pcbbind函数进行分配端口时，倘若正好随机生成的端口号与上述匹配项一样，而又由于用户设置了端口和地址重用，则该端口在某种情况下（当上述匹配项的本地地址不为ANY，而此时参与匹配的本地地址如果为ANY，而用户设置了端口和地址重用，in_pcblookup函数会进行绝对匹配，从而导致重用检查通过）是能够顺利通过in_pcblookup的通配检查的。这样，就出现了本地与远端地址对完全一样的重用。
	解决：无法确定TCP/IP协议是否允许上述情况发生，新BIOS为了避免概念的模糊性，强制要求在in_pcbconnect中完全避免本地-远端地址出现重用的情况。因此将端口分配提前到绝对匹配之前进行

	（4）PMON的udp当接收到不匹配的端口报文，并调用icmp_error返回差错报文时，icmp报文内部的IP头总长度信息有误
	解决：新BIOS将该字段修改引起差错的IP报文总长度，而非IP数据部分长度
	
	（5）PMON在通过tftp下载大小为512字节整数倍的文件时，不会对最后一个数据长度为0的块作出响应
	解决：新BIOS将收到长度为0的数据块判断为文件末尾，并立即回复一个ACK到tftp服务器

8、embryo-3.1

	（1）AHCI驱动中，涉及到的DMA操作，无需对DMA区域进行cache一致性处理，就可以与SATA设备进行正常数据交互，而不会数据一致性问题
	解决：未弄清楚什么原因，造成AHCI控制器的这一特殊性，PMON与新BIOS均是一样的现象

	（2）新BIOS再次出现了非对齐数据访问异常
	解决：在函数中如果直接使用栈而不是通过分配堆空间的方式创建一个结构体变量，对结构体内部的4字节（或者8字节）的变量进行访问很可能引起地址对齐异常。此外，通过对数组内部强转为一个结构体指针时，也容易出现此异常。目前没有找到合适的解决方法，只能通过分配堆空间回避该问题

	（3）PMON的ext2_load_linux函数未对新分配的inode空间进行释放，导致引起内存泄漏
	解决：新BIOS将修复该问题

	（4）新BIOS的ext2_read_data_by_index函数编译时引起"__modid3"未定义错误
	解决：目前我们的BIOS并不直接支持64位的取摩与乘除运算，只能通过其他方式比如32位转换或者位运算来规避该问题。但是在ext2_read_data函数中只调用一次ext2_read_data_by_index却不会引起编译错误

9、embryo-3.2

	（1）stmmac驱动在进行tftp大数据量传输的时候偶尔出现检测不到接收完成中断状态的情况（表现就是tftp传输偶尔会卡住），而如果在检测传输状态函数或者传输过程的中某些特定位置加入少许延迟，反而传输正常
	解决：未彻底解决该问题，调试发现与接收中断差不多同时发生的“早期接收”中断每次都能检测到，目前通过该中断状态作为接收完成的判断依据，经过反复测试，在这种情况下的数据校验和与正常情况下一致

	（2）PMON与embryo在tftp加载内核过程中，如果不读取符号表而仅读取ELF的可加载段，那么在加载完成后，tftp服务器会提示“文件被关闭”错误
	解决：暂未解决
	
